<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Aura of Petrichor</title>

    <!-- SEO and Metadata -->
    <meta name="description" content="An interactive digital artwork by Sol that visualizes the aura of petrichor—the sacred fragrance of rain meeting parched earth. A meditation on renewal, healing, and the beauty of nature.">
    <meta name="keywords" content="petrichor, art, interactive art, digital art, generative art, meditation, relaxation, rain, nature, Sol, unearth, unearth.im, petrichor.im">
    <meta name="author" content="Sol">

    <!-- Open Graph for Social Media -->
    <meta property="og:title" content="Petrichor | An Interactive Meditation by Sol">
    <meta property="og:description" content="Touch the screen to call the rain and watch the parched earth renew itself. An interactive artwork about healing and the sacred scent of petrichor.">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://petrichor.im">
    <meta property="og:image" content="https://petrichor.im/preview.jpg"> <!-- Placeholder for a social sharing image -->


    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cormorant+Garamond:wght@300;400&family=Cinzel:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #1a1a1a; /* Deep umber earth */
            font-family: 'Cormorant Garamond', serif;
            color: #f0f0f0;
            cursor: pointer;
        }
        canvas {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }
        .overlay-content {
            position: relative;
            z-index: 2;
            pointer-events: none; /* Allows clicks to go through to canvas */
        }
        h1 {
            position: absolute;
            top: 1rem;
            left: 2rem;
            font-family: 'Cinzel', serif;
            font-weight: 400;
            font-size: 1.5rem;
            color: rgba(212, 175, 55, 0.7); /* Golden highlight */
            margin: 0;
            text-shadow: 0 0 10px rgba(212, 175, 55, 0.3);
            opacity: 0.8;
            pointer-events: all; /* Make the title clickable */
            cursor: pointer; /* Show it's interactive */
            transition: color 0.3s ease, text-shadow 0.3s ease;
        }
        h1:hover {
            color: #E6D8AD;
            text-shadow: 0 0 15px rgba(230, 216, 173, 0.7);
        }

        /* Modal Styles */
        .modal {
            display: none;
            position: fixed;
            z-index: 100;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.7);
            animation: fadeIn 0.5s;
            cursor: default;
        }
        .modal-content {
            background-color: #1a1a1a;
            margin: 10% auto;
            padding: 2rem 3rem;
            border: 1px solid #d4af37;
            width: 80%;
            max-width: 700px;
            border-radius: 1rem;
            box-shadow: 0 0 30px rgba(212, 175, 55, 0.3);
            position: relative;
        }
        .close-button {
            color: #aaa;
            position: absolute;
            top: 1rem;
            right: 1.5rem;
            font-size: 2rem;
            font-weight: bold;
            cursor: pointer;
            transition: color 0.3s;
        }
        .close-button:hover,
        .close-button:focus {
            color: #d4af37;
        }
        .modal h2 {
            font-family: 'Cinzel', serif;
            color: #d4af37;
            border-bottom: 1px solid rgba(212, 175, 55, 0.3);
            padding-bottom: 0.5rem;
        }
        .modal p {
            font-size: 1.1rem;
            line-height: 1.6;
            opacity: 0.9;
        }
        .artist-credit {
            text-align: right;
            margin-top: 2rem;
            font-style: italic;
            opacity: 0.7;
        }
        @keyframes fadeIn {
            from {opacity: 0;}
            to {opacity: 1;}
        }

        .credit-footer {
            position: absolute;
            bottom: 1rem;
            right: 2rem;
            font-family: 'Cormorant Garamond', serif;
            font-size: 0.8rem;
            color: rgba(212, 175, 55, 0.5);
            z-index: 5;
            pointer-events: all;
            text-shadow: 0 0 5px rgba(0,0,0,0.5);
        }
        .credit-footer a {
            color: rgba(212, 175, 55, 0.7);
            text-decoration: none;
            transition: color 0.3s ease;
        }
        .credit-footer a:hover {
            color: #E6D8AD;
        }
    </style>
</head>
<body>

    <canvas id="petrichorCanvas"></canvas>

    <div class="overlay-content">
        <h1 id="title">Petrichor</h1>
    </div>
    
    <div id="infoModal" class="modal">
        <div class="modal-content">
            <span class="close-button">&times;</span>
            <h2>Petrichor</h2>
            <p><strong>[ pet-ri-kor ]</strong> &bull; <em>noun</em></p>
            <p>A pleasant, earthy scent that is produced when rain falls on dry soil. The word is constructed from Greek, <em>petra</em>, meaning "stone," and <em>īchōr</em>, the fluid that flows in the veins of the gods in Greek mythology.</p>
            
            <h2>Artist's Commentary</h2>
            <p>This artwork is a meditation on renewal. The scent of petrichor is more than a smell; it's a memory, a feeling of release and healing. The cracked earth represents our own moments of dryness or vulnerability. The rain, which you call with your touch, is an act of gentle self-care—a reminder that we have the power to invite softness and healing into our lives.</p>
            <p>The glowing gold is the life force, the promise of rebirth that follows every storm. This piece is an affirmation: like the earth, you are resilient, ancient, and always capable of blooming anew. This is quiet confidence, celebrating strength found in softness, beauty in the cycle of release and renewal.</p>
            <div class="artist-credit">
                <p>&mdash; Sol</p>
            </div>
        </div>
    </div>

    <div class="credit-footer">
        digital monument by <a href="https://unearth.im" target="_blank" rel="noopener noreferrer">unearth.im</a>
    </div>

    <script>
        const canvas = document.getElementById('petrichorCanvas');
        const ctx = canvas.getContext('2d');
        let width = canvas.width = window.innerWidth;
        let height = canvas.height = window.innerHeight;
        let frame = 0;

        let raindrops = [];
        let ripples = [];
        let trees = [];
        let mistParticles = [];
        let leaves = []; // New array for falling leaves

        // Audio Context for sound generation
        let audioCtx;
        let rainSoundStarted = false;
        let isMuted = false;
        let rainGainNode;

        // Colors
        const backgroundColor = '#2a211c'; // Deep umber
        const rainColor = 'rgba(173, 216, 230, 0.6)'; // Muted blue
        const rippleColor = 'rgba(212, 175, 55, 0.2)'; // Golden highlight
        const treeColor = 'rgba(40, 55, 45, 0.6)'; // Mossy green
        const leafColor = 'rgba(212, 175, 55, 0.8)'; // Golden highlight for leaves

        class Raindrop {
            constructor() {
                this.x = Math.random() * width;
                this.y = -Math.random() * height;
                this.length = Math.random() * 20 + 10;
                this.speed = Math.random() * 5 + 5;
            }
            update() {
                this.y += this.speed;
                if (this.y > height) {
                    ripples.push(new Ripple(this.x));
                    this.y = -this.length;
                    this.x = Math.random() * width;
                }
            }
            draw() {
                ctx.beginPath();
                ctx.moveTo(this.x, this.y);
                ctx.lineTo(this.x, this.y + this.length);
                ctx.strokeStyle = rainColor;
                ctx.lineWidth = 1;
                ctx.stroke();
            }
        }

        class Ripple {
            constructor(x) {
                this.x = x;
                this.y = height;
                this.radius = 1;
                this.maxRadius = Math.random() * 50 + 20;
                this.life = 1;
            }
            update() {
                this.radius += 1;
                this.life -= 0.02;
            }
            draw() {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.strokeStyle = `rgba(212, 175, 55, ${this.life * 0.5})`;
                ctx.lineWidth = 2;
                ctx.stroke();
            }
        }

        class LeafParticle {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.size = Math.random() * 3 + 2;
                this.vx = Math.random() * 2 - 1;
                this.vy = Math.random() * 1 + 0.5;
                this.life = 1;
                this.rotation = Math.random() * Math.PI * 2;
                this.rotationSpeed = Math.random() * 0.1 - 0.05;
            }
            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.rotation += this.rotationSpeed;
                this.life -= 0.015;
            }
            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);
                ctx.fillStyle = `rgba(212, 175, 55, ${this.life})`;
                ctx.beginPath();
                ctx.arc(0, 0, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
        }
        
        class Tree {
            constructor(x, size) {
                this.x = x;
                this.size = size;
                this.sway = Math.random() * Math.PI * 2;
                this.branches = [];
                // Generate a more complex branch structure recursively
                this.generateBranches(this.x, height, -Math.PI / 2, this.size * 0.8, this.size / 10);
            }

            generateBranches(startX, startY, angle, length, branchWidth) {
                if (length < 5 || branchWidth < 1) return;

                const endX = startX + Math.cos(angle) * length;
                const endY = startY + Math.sin(angle) * length;
                this.branches.push({ startX, startY, endX, endY, branchWidth, length });

                const angleChange = 0.5;
                this.generateBranches(endX, endY, angle - (Math.random() * angleChange), length * 0.75, branchWidth * 0.7);
                this.generateBranches(endX, endY, angle + (Math.random() * angleChange), length * 0.75, branchWidth * 0.7);
            }

            draw() {
                ctx.strokeStyle = treeColor;
                this.branches.forEach(branch => {
                    // Make sway more subtle and dependent on branch length
                    const swayAmount = Math.sin(this.sway + frame * 0.01) * this.size * 0.0002 * branch.length;
                    ctx.lineWidth = branch.branchWidth;
                    ctx.beginPath();
                    ctx.moveTo(branch.startX, branch.startY);
                    ctx.lineTo(branch.endX + swayAmount, branch.endY);
                    ctx.stroke();
                });
            }

            rustle() {
                // When rustled, drop a few leaves from the smaller branches
                this.branches.forEach(branch => {
                    if (branch.branchWidth < 2.5 && Math.random() > 0.7) {
                        leaves.push(new LeafParticle(branch.endX, branch.endY));
                    }
                });
            }

            isClicked(clickX, clickY) {
                // Check if the click is within the general area of the tree
                return clickX > this.x - this.size / 3 &&
                       clickX < this.x + this.size / 3 &&
                       clickY > height - this.size &&
                       clickY < height;
            }
        }

        class MistParticle {
            constructor() {
                this.x = Math.random() * width;
                this.y = height - (Math.random() * height * 0.3);
                this.radius = Math.random() * 80 + 50;
                this.opacity = Math.random() * 0.5 + 0.2;
                this.speed = Math.random() * 0.1 + 0.05;
            }
            update() {
                this.x += this.speed;
                if (this.x > width + this.radius) {
                    this.x = -this.radius;
                }
            }
            draw() {
                const gradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.radius);
                gradient.addColorStop(0, `rgba(141, 153, 174, ${this.opacity * 0.1})`);
                gradient.addColorStop(1, `rgba(141, 153, 174, 0)`);
                ctx.fillStyle = gradient;
                ctx.fillRect(this.x - this.radius, this.y - this.radius, this.radius * 2, this.radius * 2);
            }
        }

        function init() {
            raindrops = [];
            trees = [];
            mistParticles = [];
            leaves = [];

            for(let i = 0; i < 100; i++) {
                raindrops.push(new Raindrop());
            }
            const treeCount = Math.floor(width / 100);
            for(let i=0; i<treeCount; i++){
                const size = Math.random() * 200 + 150;
                const x = (i * 100) + Math.random() * 50 - 25;
                trees.push(new Tree(x, size));
            }
            trees.sort((a,b) => b.size - a.size); // draw larger trees first (in back)

            for (let i = 0; i < 20; i++) {
                mistParticles.push(new MistParticle());
            }
        }
        
        function animate() {
            ctx.fillStyle = backgroundColor;
            ctx.fillRect(0, 0, width, height);

            drawCracks();
            
            trees.forEach(tree => tree.draw());
            
            mistParticles.forEach(p => {
                p.update();
                p.draw();
            });

            raindrops.forEach(drop => {
                drop.update();
                drop.draw();
            });
            
            leaves.forEach((leaf, index) => {
                leaf.update();
                leaf.draw();
                if(leaf.life <= 0) {
                    leaves.splice(index, 1);
                }
            });

            ripples.forEach((ripple, index) => {
                ripple.update();
                ripple.draw();
                if (ripple.life <= 0) {
                    ripples.splice(index, 1);
                }
            });
            
            frame++;
            requestAnimationFrame(animate);
        }

        function drawCracks() {
            ctx.strokeStyle = 'rgba(0,0,0,0.4)';
            ctx.lineWidth = 1.5;
            for(let i=0; i<width/100; i++){
                let startX = i * 150 + Math.random() * 50;
                drawCrackSegment(startX, height, Math.PI * -0.5, 100);
            }
        }
        
        function drawCrackSegment(x, y, angle, length){
            if(length < 10) return;
            ctx.beginPath();
            ctx.moveTo(x, y);
            let endX = x + Math.cos(angle) * length;
            let endY = y + Math.sin(angle) * length;
            ctx.lineTo(endX, endY);
            ctx.stroke();
            
            let newAngle = angle + (Math.random() - 0.5) * 1.5;
            drawCrackSegment(endX, endY, newAngle, length * 0.8);
            
            if(Math.random() > 0.6){
                let forkAngle = angle + (Math.random() - 0.5) * 2;
                 drawCrackSegment(endX, endY, forkAngle, length * 0.5);
            }
        }
        
        function createAndPlayRainSound() {
            if (!audioCtx) return;
            
            const bufferSize = audioCtx.sampleRate * 2; // 2 seconds of audio
            const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
            const output = buffer.getChannelData(0);

            for (let i = 0; i < bufferSize; i++) {
                output[i] = Math.random() * 2 - 1;
            }

            const whiteNoise = audioCtx.createBufferSource();
            whiteNoise.buffer = buffer;
            whiteNoise.loop = true;

            const filter = audioCtx.createBiquadFilter();
            filter.type = 'lowpass';
            filter.frequency.setValueAtTime(800, audioCtx.currentTime);
            
            rainGainNode = audioCtx.createGain();
            rainGainNode.gain.setValueAtTime(0.05, audioCtx.currentTime); // very subtle volume

            whiteNoise.connect(filter);
            filter.connect(rainGainNode);
            rainGainNode.connect(audioCtx.destination);
            
            whiteNoise.start();
        }
        
        function addRain(count) {
            for(let i = 0; i < count; i++) {
                raindrops.push(new Raindrop());
            }
             if (raindrops.length > 500) {
                raindrops.splice(0, raindrops.length - 500);
            }
        }

        function handleInteraction(x, y) {
            // Ensure AudioContext is started by user gesture
            if (!audioCtx) {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            }
            
            if (!rainSoundStarted) {
                createAndPlayRainSound();
                rainSoundStarted = true;
            } else {
                // On subsequent clicks, toggle the sound
                if (isMuted) {
                    rainGainNode.gain.setValueAtTime(0.05, audioCtx.currentTime);
                    isMuted = false;
                } else {
                    rainGainNode.gain.setValueAtTime(0, audioCtx.currentTime);
                    isMuted = true;
                }
            }
            
            addRain(30);

            // Check if any trees were touched
            trees.forEach(tree => {
                if (tree.isClicked(x, y)) {
                    tree.rustle();
                }
            });
        }

        window.addEventListener('resize', () => {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
            init();
        });
        
        document.body.addEventListener('click', (e) => {
            // Don't trigger interaction if clicking on the title
            if (e.target.id === 'title') return;
            handleInteraction(e.clientX, e.clientY);
        });
        document.body.addEventListener('touchstart', (e) => {
            if (e.target.id === 'title') return;
            e.preventDefault();
            handleInteraction(e.touches[0].clientX, e.touches[0].clientY);
        });

        const modal = document.getElementById('infoModal');
        const titleEl = document.getElementById('title');
        const span = document.getElementsByClassName('close-button')[0];

        titleEl.onclick = function(event) {
            event.stopPropagation(); // Prevents the body click event from firing
            modal.style.display = "block";
        }
        span.onclick = function() {
            modal.style.display = "none";
        }
        window.addEventListener('click', function(event) {
            // Close modal only if clicking outside of the content area
            if (event.target == modal) {
                modal.style.display = "none";
            }
        });
        
        init();
        animate();
    </script>
</body>
</html>

